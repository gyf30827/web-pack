{"version":3,"sources":["helpers.js"],"names":[],"mappings":"AAAA;AACA;AACA,QAAQ,aAAR,GAAwB,UAAS,KAAT,EAAgB;AACvC,KAAI,MAAM,MAAM,MAAhB;AAAA,KAAwB,IAAxB;AAAA,KAA8B,QAA9B;AAAA,KAAwC,OAAxC;;AAEA;AACA;AACA,QAAO,EAAE,GAAF,GAAQ,CAAC,CAAhB,EAAmB;AAClB,SAAO,WAAW,MAAM,GAAN,CAAlB;;AAEA;AACA,QAAM,GAAN,IAAa,IAAb;AACA,YAAU,IAAV;;AAEA,SAAO,QAAP,EAAiB;AAChB,OAAI,MAAM,OAAN,CAAc,QAAd,IAA0B,CAAC,CAA/B,EAAkC;AACjC,cAAU,KAAV;AACA,UAAM,MAAN,CAAa,GAAb,EAAkB,CAAlB;AACA;AACA;AACD,cAAW,SAAS,MAApB;AACA;;AAED;AACA,MAAI,OAAJ,EAAa;AACZ,SAAM,GAAN,IAAa,IAAb;AACA;AACD;;AAED,QAAO,KAAP;AACA,CA5BD;;AA8BA;AACA,IAAI,WAAW;AACd,eAAc,CADA;AAEd,YAAW,CAFG;AAGd,YAAW,CAHG;AAId,WAAU,CAJI;AAKd,eAAc;AALA,CAAf;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,aAAa,QAAQ,uBAAR,GAAkC,UAAS,KAAT,EAAgB,KAAhB,EAAuB;AACzE,KAAI,WAAW,EAAf;AACA,KAAI,WAAW,EAAf;AACA,KAAI,OAAJ,EAAa,YAAb,EAA2B,QAA3B,EAAqC,QAArC,EAA+C,QAA/C,EAAyD,GAAzD;;AAEA,KAAI,UAAU,KAAd,EAAqB;AACpB,SAAO,CAAP;AACA;;AAED,WAAU,KAAV;AACA,QAAO,OAAP,EAAgB;AACf,WAAS,OAAT,CAAiB,OAAjB;AACA,YAAU,QAAQ,MAAlB;AACA;AACD,WAAU,KAAV;AACA,QAAO,OAAP,EAAgB;AACf,WAAS,OAAT,CAAiB,OAAjB;AACA,YAAU,QAAQ,MAAlB;AACA;;AAED,OAAM,CAAN;AACA,QAAO,SAAS,GAAT,MAAkB,SAAS,GAAT,CAAzB,EAAwC;AACvC;AACA;;AAED,KAAI,QAAQ,CAAZ,EAAe;AACd,SAAO,SAAS,YAAhB;AACA;;AAED,gBAAe,SAAS,MAAM,CAAf,CAAf;AACA,YAAW,aAAa,QAAxB;AACA,YAAW,SAAS,GAAT,CAAX;AACA,YAAW,SAAS,GAAT,CAAX;;AAEA,KAAI,SAAS,OAAT,CAAiB,QAAjB,IAA6B,SAAS,OAAT,CAAiB,QAAjB,CAAjC,EAA6D;AAC5D,MAAI,iBAAiB,KAArB,EAA4B;AAC3B,UAAO,SAAS,SAAT,GAAqB,SAAS,YAArC;AACA;AACD,SAAO,SAAS,SAAhB;AACA,EALD,MAKO;AACN,MAAI,iBAAiB,KAArB,EAA4B;AAC3B,UAAO,SAAS,SAAT,GAAqB,SAAS,QAArC;AACA;AACD,SAAO,SAAS,SAAhB;AACA;AACD,CA7CD;;AA+CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,UAAR,GAAqB,UAAS,KAAT,EAAgB;AACpC,KAAI,MAAM,MAAM,MAAhB;AAAA,KAAwB,IAAxB;AAAA,KAA8B,QAA9B;;AAEA,SAAQ,MAAM,KAAN,EAAR;;AAEA,QAAO,EAAE,GAAF,GAAQ,CAAC,CAAhB,EAAmB;AAClB,SAAO,MAAM,GAAN,CAAP;AACA,aAAW,MAAM,OAAN,CAAc,IAAd,CAAX;AACA,MAAI,WAAW,CAAC,CAAZ,IAAiB,WAAW,GAAhC,EAAqC;AACpC,SAAM,MAAN,CAAa,GAAb,EAAkB,CAAlB;AACA;AACD;AACD,OAAM,IAAN,CAAW,UAAS,CAAT,EAAY,CAAZ,EAAe;AACzB,MAAI,WAAW,WAAW,CAAX,EAAc,CAAd,CAAf;AACA,MAAI,WAAW,SAAS,SAAxB,EAAmC;AAClC,UAAO,CAAC,CAAR;AACA,GAFD,MAEO,IAAI,WAAW,SAAS,SAAxB,EAAmC;AACzC,UAAO,CAAP;AACA;AACD,SAAO,CAAP;AACA,EARD;;AAUA,QAAO,KAAP;AACA,CAvBD","file":"helpers-compiled.js","sourcesContent":["// removeSubsets\n// Given an array of nodes, remove any member that is contained by another.\nexports.removeSubsets = function(nodes) {\n\tvar idx = nodes.length, node, ancestor, replace;\n\n\t// Check if each node (or one of its ancestors) is already contained in the\n\t// array.\n\twhile (--idx > -1) {\n\t\tnode = ancestor = nodes[idx];\n\n\t\t// Temporarily remove the node under consideration\n\t\tnodes[idx] = null;\n\t\treplace = true;\n\n\t\twhile (ancestor) {\n\t\t\tif (nodes.indexOf(ancestor) > -1) {\n\t\t\t\treplace = false;\n\t\t\t\tnodes.splice(idx, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tancestor = ancestor.parent;\n\t\t}\n\n\t\t// If the node has been found to be unique, re-insert it.\n\t\tif (replace) {\n\t\t\tnodes[idx] = node;\n\t\t}\n\t}\n\n\treturn nodes;\n};\n\n// Source: http://dom.spec.whatwg.org/#dom-node-comparedocumentposition\nvar POSITION = {\n\tDISCONNECTED: 1,\n\tPRECEDING: 2,\n\tFOLLOWING: 4,\n\tCONTAINS: 8,\n\tCONTAINED_BY: 16\n};\n\n// Compare the position of one node against another node in any other document.\n// The return value is a bitmask with the following values:\n//\n// document order:\n// > There is an ordering, document order, defined on all the nodes in the\n// > document corresponding to the order in which the first character of the\n// > XML representation of each node occurs in the XML representation of the\n// > document after expansion of general entities. Thus, the document element\n// > node will be the first node. Element nodes occur before their children.\n// > Thus, document order orders element nodes in order of the occurrence of\n// > their start-tag in the XML (after expansion of entities). The attribute\n// > nodes of an element occur after the element and before its children. The\n// > relative order of attribute nodes is implementation-dependent./\n// Source:\n// http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order\n//\n// @argument {Node} nodaA The first node to use in the comparison\n// @argument {Node} nodeB The second node to use in the comparison\n//\n// @return {Number} A bitmask describing the input nodes' relative position.\n//         See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for\n//         a description of these values.\nvar comparePos = exports.compareDocumentPosition = function(nodeA, nodeB) {\n\tvar aParents = [];\n\tvar bParents = [];\n\tvar current, sharedParent, siblings, aSibling, bSibling, idx;\n\n\tif (nodeA === nodeB) {\n\t\treturn 0;\n\t}\n\n\tcurrent = nodeA;\n\twhile (current) {\n\t\taParents.unshift(current);\n\t\tcurrent = current.parent;\n\t}\n\tcurrent = nodeB;\n\twhile (current) {\n\t\tbParents.unshift(current);\n\t\tcurrent = current.parent;\n\t}\n\n\tidx = 0;\n\twhile (aParents[idx] === bParents[idx]) {\n\t\tidx++;\n\t}\n\n\tif (idx === 0) {\n\t\treturn POSITION.DISCONNECTED;\n\t}\n\n\tsharedParent = aParents[idx - 1];\n\tsiblings = sharedParent.children;\n\taSibling = aParents[idx];\n\tbSibling = bParents[idx];\n\n\tif (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {\n\t\tif (sharedParent === nodeB) {\n\t\t\treturn POSITION.FOLLOWING | POSITION.CONTAINED_BY;\n\t\t}\n\t\treturn POSITION.FOLLOWING;\n\t} else {\n\t\tif (sharedParent === nodeA) {\n\t\t\treturn POSITION.PRECEDING | POSITION.CONTAINS;\n\t\t}\n\t\treturn POSITION.PRECEDING;\n\t}\n};\n\n// Sort an array of nodes based on their relative position in the document and\n// remove any duplicate nodes. If the array contains nodes that do not belong\n// to the same document, sort order is unspecified.\n//\n// @argument {Array} nodes Array of DOM nodes\n//\n// @returns {Array} collection of unique nodes, sorted in document order\nexports.uniqueSort = function(nodes) {\n\tvar idx = nodes.length, node, position;\n\n\tnodes = nodes.slice();\n\n\twhile (--idx > -1) {\n\t\tnode = nodes[idx];\n\t\tposition = nodes.indexOf(node);\n\t\tif (position > -1 && position < idx) {\n\t\t\tnodes.splice(idx, 1);\n\t\t}\n\t}\n\tnodes.sort(function(a, b) {\n\t\tvar relative = comparePos(a, b);\n\t\tif (relative & POSITION.PRECEDING) {\n\t\t\treturn -1;\n\t\t} else if (relative & POSITION.FOLLOWING) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t});\n\n\treturn nodes;\n};\n"]}