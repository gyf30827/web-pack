{"version":3,"sources":["fetchWithRetries.js"],"names":[],"mappings":"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","file":"fetchWithRetries-compiled.js","sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n * \n */\n\n'use strict';\n\nvar Promise = require('./Promise');\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nvar ExecutionEnvironment = require('./ExecutionEnvironment');\n\nvar sprintf = require('./sprintf');\nvar fetch = require('./fetch');\nvar warning = require('./warning');\n\nvar DEFAULT_TIMEOUT = 15000;\nvar DEFAULT_RETRIES = [1000, 3000];\n\n/**\n * Makes a POST request to the server with the given data as the payload.\n * Automatic retries are done based on the values in `retryDelays`.\n */\nfunction fetchWithRetries(uri, initWithRetries) {\n  var _ref = initWithRetries || {},\n      fetchTimeout = _ref.fetchTimeout,\n      retryDelays = _ref.retryDelays,\n      init = _objectWithoutProperties(_ref, ['fetchTimeout', 'retryDelays']);\n\n  var _fetchTimeout = fetchTimeout != null ? fetchTimeout : DEFAULT_TIMEOUT;\n  var _retryDelays = retryDelays != null ? retryDelays : DEFAULT_RETRIES;\n\n  var requestsAttempted = 0;\n  var requestStartTime = 0;\n  return new Promise(function (resolve, reject) {\n    /**\n     * Sends a request to the server that will timeout after `fetchTimeout`.\n     * If the request fails or times out a new request might be scheduled.\n     */\n    function sendTimedRequest() {\n      requestsAttempted++;\n      requestStartTime = Date.now();\n      var isRequestAlive = true;\n      var request = fetch(uri, init);\n      var requestTimeout = setTimeout(function () {\n        isRequestAlive = false;\n        if (shouldRetry(requestsAttempted)) {\n          process.env.NODE_ENV !== 'production' ? warning(false, 'fetchWithRetries: HTTP timeout, retrying.') : void 0;\n          retryRequest();\n        } else {\n          reject(new Error(sprintf('fetchWithRetries(): Failed to get response from server, ' + 'tried %s times.', requestsAttempted)));\n        }\n      }, _fetchTimeout);\n\n      request.then(function (response) {\n        clearTimeout(requestTimeout);\n        if (isRequestAlive) {\n          // We got a response, we can clear the timeout.\n          if (response.status >= 200 && response.status < 300) {\n            // Got a response code that indicates success, resolve the promise.\n            resolve(response);\n          } else if (shouldRetry(requestsAttempted)) {\n            // Fetch was not successful, retrying.\n            // TODO(#7595849): Only retry on transient HTTP errors.\n            process.env.NODE_ENV !== 'production' ? warning(false, 'fetchWithRetries: HTTP error, retrying.') : void 0, retryRequest();\n          } else {\n            // Request was not successful, giving up.\n            var error = new Error(sprintf('fetchWithRetries(): Still no successful response after ' + '%s retries, giving up.', requestsAttempted));\n            error.response = response;\n            reject(error);\n          }\n        }\n      })['catch'](function (error) {\n        clearTimeout(requestTimeout);\n        if (shouldRetry(requestsAttempted)) {\n          retryRequest();\n        } else {\n          reject(error);\n        }\n      });\n    }\n\n    /**\n     * Schedules another run of sendTimedRequest based on how much time has\n     * passed between the time the last request was sent and now.\n     */\n    function retryRequest() {\n      var retryDelay = _retryDelays[requestsAttempted - 1];\n      var retryStartTime = requestStartTime + retryDelay;\n      // Schedule retry for a configured duration after last request started.\n      setTimeout(sendTimedRequest, retryStartTime - Date.now());\n    }\n\n    /**\n     * Checks if another attempt should be done to send a request to the server.\n     */\n    function shouldRetry(attempt) {\n      return ExecutionEnvironment.canUseDOM && attempt <= _retryDelays.length;\n    }\n\n    sendTimedRequest();\n  });\n}\n\nmodule.exports = fetchWithRetries;"]}