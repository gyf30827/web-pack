{"version":3,"sources":["compile.js"],"names":[],"mappings":"AAAA,OAAO,OAAP,GAAiB,OAAjB;;AAEA,IAAI,YAAY,QAAQ,UAAR,CAAhB;AAAA,IACI,WAAY,UAAU,QAD1B;AAAA,IAEI,YAAY,UAAU,SAF1B;;AAIA;;;;AAIA,SAAS,OAAT,CAAiB,MAAjB,EAAwB;AACvB,KAAI,IAAI,OAAO,CAAP,CAAR;AAAA,KACI,IAAI,OAAO,CAAP,IAAY,CADpB;;AAGA;AACA;AACA,KAAG,IAAI,CAAJ,IAAS,KAAK,CAAjB,EAAoB,OAAO,SAAP;;AAEpB;AACA,KAAG,MAAK,CAAC,CAAT,EAAY,OAAO,UAAS,GAAT,EAAa;AAAE,SAAO,OAAO,CAAd;AAAkB,EAAxC;AACZ,KAAG,MAAM,CAAT,EAAY,OAAO,UAAS,GAAT,EAAa;AAAE,SAAO,QAAQ,CAAf;AAAmB,EAAzC;AACZ;AACA,KAAG,MAAM,CAAT,EAAY,OAAO,IAAI,CAAJ,GAAQ,QAAR,GAAmB,UAAS,GAAT,EAAa;AAAE,SAAO,OAAO,CAAd;AAAkB,EAA3D;;AAEZ;AACA,KAAI,OAAO,IAAI,CAAf;AACA,KAAG,OAAO,CAAV,EAAa,QAAQ,CAAR;;AAEb,KAAG,IAAI,CAAP,EAAS;AACR,SAAO,UAAS,GAAT,EAAa;AACnB,UAAO,OAAO,CAAP,IAAY,MAAM,CAAN,KAAY,IAA/B;AACA,GAFD;AAGA;;AAED,MAAK,CAAC,CAAN,CAxBuB,CAwBd;;AAET,QAAO,UAAS,GAAT,EAAa;AACnB,SAAO,OAAO,CAAP,IAAY,MAAM,CAAN,KAAY,IAA/B;AACA,EAFD;AAGA","file":"compile-compiled.js","sourcesContent":["module.exports = compile;\n\nvar BaseFuncs = require(\"boolbase\"),\n    trueFunc  = BaseFuncs.trueFunc,\n    falseFunc = BaseFuncs.falseFunc;\n\n/*\n\treturns a function that checks if an elements index matches the given rule\n\thighly optimized to return the fastest solution\n*/\nfunction compile(parsed){\n\tvar a = parsed[0],\n\t    b = parsed[1] - 1;\n\n\t//when b <= 0, a*n won't be possible for any matches when a < 0\n\t//besides, the specification says that no element is matched when a and b are 0\n\tif(b < 0 && a <= 0) return falseFunc;\n\n\t//when a is in the range -1..1, it matches any element (so only b is checked)\n\tif(a ===-1) return function(pos){ return pos <= b; };\n\tif(a === 0) return function(pos){ return pos === b; };\n\t//when b <= 0 and a === 1, they match any element\n\tif(a === 1) return b < 0 ? trueFunc : function(pos){ return pos >= b; };\n\n\t//when a > 0, modulo can be used to check if there is a match\n\tvar bMod = b % a;\n\tif(bMod < 0) bMod += a;\n\n\tif(a > 1){\n\t\treturn function(pos){\n\t\t\treturn pos >= b && pos % a === bMod;\n\t\t};\n\t}\n\n\ta *= -1; //make `a` positive\n\n\treturn function(pos){\n\t\treturn pos <= b && pos % a === bMod;\n\t};\n}"]}